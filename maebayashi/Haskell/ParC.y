-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParC where
import AbsC
import LexC
import ErrM

}

%name pProgram Program
%name pStm Stm
%name pExp Exp

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '!' { PT _ (TS _ 1) }
 '!=' { PT _ (TS _ 2) }
 '%' { PT _ (TS _ 3) }
 '%=' { PT _ (TS _ 4) }
 '&' { PT _ (TS _ 5) }
 '&&' { PT _ (TS _ 6) }
 '&=' { PT _ (TS _ 7) }
 '(' { PT _ (TS _ 8) }
 ')' { PT _ (TS _ 9) }
 '*' { PT _ (TS _ 10) }
 '*=' { PT _ (TS _ 11) }
 '+' { PT _ (TS _ 12) }
 '++' { PT _ (TS _ 13) }
 '+=' { PT _ (TS _ 14) }
 ',' { PT _ (TS _ 15) }
 '-' { PT _ (TS _ 16) }
 '--' { PT _ (TS _ 17) }
 '-=' { PT _ (TS _ 18) }
 '->' { PT _ (TS _ 19) }
 '.' { PT _ (TS _ 20) }
 '...' { PT _ (TS _ 21) }
 '/' { PT _ (TS _ 22) }
 '/=' { PT _ (TS _ 23) }
 ':' { PT _ (TS _ 24) }
 ';' { PT _ (TS _ 25) }
 '<' { PT _ (TS _ 26) }
 '<<' { PT _ (TS _ 27) }
 '<<=' { PT _ (TS _ 28) }
 '<=' { PT _ (TS _ 29) }
 '=' { PT _ (TS _ 30) }
 '==' { PT _ (TS _ 31) }
 '>' { PT _ (TS _ 32) }
 '>=' { PT _ (TS _ 33) }
 '>>' { PT _ (TS _ 34) }
 '>>=' { PT _ (TS _ 35) }
 '?' { PT _ (TS _ 36) }
 'Typedef_name' { PT _ (TS _ 37) }
 '[' { PT _ (TS _ 38) }
 ']' { PT _ (TS _ 39) }
 '^' { PT _ (TS _ 40) }
 '^=' { PT _ (TS _ 41) }
 'auto' { PT _ (TS _ 42) }
 'break' { PT _ (TS _ 43) }
 'case' { PT _ (TS _ 44) }
 'char' { PT _ (TS _ 45) }
 'const' { PT _ (TS _ 46) }
 'continue' { PT _ (TS _ 47) }
 'default' { PT _ (TS _ 48) }
 'do' { PT _ (TS _ 49) }
 'double' { PT _ (TS _ 50) }
 'else' { PT _ (TS _ 51) }
 'enum' { PT _ (TS _ 52) }
 'extern' { PT _ (TS _ 53) }
 'float' { PT _ (TS _ 54) }
 'for' { PT _ (TS _ 55) }
 'goto' { PT _ (TS _ 56) }
 'if' { PT _ (TS _ 57) }
 'int' { PT _ (TS _ 58) }
 'long' { PT _ (TS _ 59) }
 'register' { PT _ (TS _ 60) }
 'return' { PT _ (TS _ 61) }
 'short' { PT _ (TS _ 62) }
 'signed' { PT _ (TS _ 63) }
 'sizeof' { PT _ (TS _ 64) }
 'static' { PT _ (TS _ 65) }
 'struct' { PT _ (TS _ 66) }
 'switch' { PT _ (TS _ 67) }
 'typedef' { PT _ (TS _ 68) }
 'union' { PT _ (TS _ 69) }
 'unsigned' { PT _ (TS _ 70) }
 'void' { PT _ (TS _ 71) }
 'volatile' { PT _ (TS _ 72) }
 'while' { PT _ (TS _ 73) }
 '{' { PT _ (TS _ 74) }
 '|' { PT _ (TS _ 75) }
 '|=' { PT _ (TS _ 76) }
 '||' { PT _ (TS _ 77) }
 '}' { PT _ (TS _ 78) }
 '~' { PT _ (TS _ 79) }

L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_integ  { PT _ (TI $$) }
L_Unsigned { PT _ (T_Unsigned $$) }
L_Long { PT _ (T_Long $$) }
L_UnsignedLong { PT _ (T_UnsignedLong $$) }
L_Hexadecimal { PT _ (T_Hexadecimal $$) }
L_HexUnsigned { PT _ (T_HexUnsigned $$) }
L_HexLong { PT _ (T_HexLong $$) }
L_HexUnsLong { PT _ (T_HexUnsLong $$) }
L_Octal { PT _ (T_Octal $$) }
L_OctalUnsigned { PT _ (T_OctalUnsigned $$) }
L_OctalLong { PT _ (T_OctalLong $$) }
L_OctalUnsLong { PT _ (T_OctalUnsLong $$) }
L_CDouble { PT _ (T_CDouble $$) }
L_CFloat { PT _ (T_CFloat $$) }
L_CLongDouble { PT _ (T_CLongDouble $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted {  $1 }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Unsigned    :: { Unsigned} : L_Unsigned { Unsigned ($1)}
Long    :: { Long} : L_Long { Long ($1)}
UnsignedLong    :: { UnsignedLong} : L_UnsignedLong { UnsignedLong ($1)}
Hexadecimal    :: { Hexadecimal} : L_Hexadecimal { Hexadecimal ($1)}
HexUnsigned    :: { HexUnsigned} : L_HexUnsigned { HexUnsigned ($1)}
HexLong    :: { HexLong} : L_HexLong { HexLong ($1)}
HexUnsLong    :: { HexUnsLong} : L_HexUnsLong { HexUnsLong ($1)}
Octal    :: { Octal} : L_Octal { Octal ($1)}
OctalUnsigned    :: { OctalUnsigned} : L_OctalUnsigned { OctalUnsigned ($1)}
OctalLong    :: { OctalLong} : L_OctalLong { OctalLong ($1)}
OctalUnsLong    :: { OctalUnsLong} : L_OctalUnsLong { OctalUnsLong ($1)}
CDouble    :: { CDouble} : L_CDouble { CDouble ($1)}
CFloat    :: { CFloat} : L_CFloat { CFloat ($1)}
CLongDouble    :: { CLongDouble} : L_CLongDouble { CLongDouble ($1)}

Program :: { Program }
Program : ListExternal_declaration { Progr $1 } 


ListExternal_declaration :: { [External_declaration] }
ListExternal_declaration : External_declaration { (:[]) $1 } 
  | External_declaration ListExternal_declaration { (:) $1 $2 }


External_declaration :: { External_declaration }
External_declaration : Function_def { Afunc $1 } 
  | Dec { Global $1 }


Function_def :: { Function_def }
Function_def : ListDeclaration_specifier Declarator ListDec Compound_stm { OldFunc $1 $2 $3 $4 } 
  | ListDeclaration_specifier Declarator Compound_stm { NewFunc $1 $2 $3 }
  | Declarator ListDec Compound_stm { OldFuncInt $1 $2 $3 }
  | Declarator Compound_stm { NewFuncInt $1 $2 }


Dec :: { Dec }
Dec : ListDeclaration_specifier ';' { NoDeclarator $1 } 
  | ListDeclaration_specifier ListInit_declarator ';' { Declarators $1 $2 }


ListDec :: { [Dec] }
ListDec : Dec { (:[]) $1 } 
  | Dec ListDec { (:) $1 $2 }


ListDeclaration_specifier :: { [Declaration_specifier] }
ListDeclaration_specifier : Declaration_specifier { (:[]) $1 } 
  | Declaration_specifier ListDeclaration_specifier { (:) $1 $2 }


Declaration_specifier :: { Declaration_specifier }
Declaration_specifier : Type_specifier { Type $1 } 
  | Storage_class_specifier { Storage $1 }
  | Type_qualifier { SpecProp $1 }


ListInit_declarator :: { [Init_declarator] }
ListInit_declarator : Init_declarator { (:[]) $1 } 
  | Init_declarator ',' ListInit_declarator { (:) $1 $3 }


Init_declarator :: { Init_declarator }
Init_declarator : Declarator { OnlyDecl $1 } 
  | Declarator '=' Initializer { InitDecl $1 $3 }


Type_specifier :: { Type_specifier }
Type_specifier : 'void' { Tvoid } 
  | 'char' { Tchar }
  | 'short' { Tshort }
  | 'int' { Tint }
  | 'long' { Tlong }
  | 'float' { Tfloat }
  | 'double' { Tdouble }
  | 'signed' { Tsigned }
  | 'unsigned' { Tunsigned }
  | Struct_or_union_spec { Tstruct $1 }
  | Enum_specifier { Tenum $1 }
  | 'Typedef_name' { Tname }


Storage_class_specifier :: { Storage_class_specifier }
Storage_class_specifier : 'typedef' { MyType } 
  | 'extern' { GlobalPrograms }
  | 'static' { LocalProgram }
  | 'auto' { LocalBlock }
  | 'register' { LocalReg }


Type_qualifier :: { Type_qualifier }
Type_qualifier : 'const' { Const } 
  | 'volatile' { NoOptim }


Struct_or_union_spec :: { Struct_or_union_spec }
Struct_or_union_spec : Struct_or_union Ident '{' ListStruct_dec '}' { Tag $1 $2 $4 } 
  | Struct_or_union '{' ListStruct_dec '}' { Unique $1 $3 }
  | Struct_or_union Ident { TagType $1 $2 }


Struct_or_union :: { Struct_or_union }
Struct_or_union : 'struct' { Struct } 
  | 'union' { Union }


ListStruct_dec :: { [Struct_dec] }
ListStruct_dec : Struct_dec { (:[]) $1 } 
  | Struct_dec ListStruct_dec { (:) $1 $2 }


Struct_dec :: { Struct_dec }
Struct_dec : ListSpec_qual ListStruct_declarator ';' { Structen $1 $2 } 


ListSpec_qual :: { [Spec_qual] }
ListSpec_qual : Spec_qual { (:[]) $1 } 
  | Spec_qual ListSpec_qual { (:) $1 $2 }


Spec_qual :: { Spec_qual }
Spec_qual : Type_specifier { TypeSpec $1 } 
  | Type_qualifier { QualSpec $1 }


ListStruct_declarator :: { [Struct_declarator] }
ListStruct_declarator : Struct_declarator { (:[]) $1 } 
  | Struct_declarator ',' ListStruct_declarator { (:) $1 $3 }


Struct_declarator :: { Struct_declarator }
Struct_declarator : Declarator { Decl $1 } 
  | ':' Constant_expression { Field $2 }
  | Declarator ':' Constant_expression { DecField $1 $3 }


Enum_specifier :: { Enum_specifier }
Enum_specifier : 'enum' '{' ListEnumerator '}' { EnumDec $3 } 
  | 'enum' Ident '{' ListEnumerator '}' { EnumName $2 $4 }
  | 'enum' Ident { EnumVar $2 }


ListEnumerator :: { [Enumerator] }
ListEnumerator : Enumerator { (:[]) $1 } 
  | Enumerator ',' ListEnumerator { (:) $1 $3 }


Enumerator :: { Enumerator }
Enumerator : Ident { Plain $1 } 
  | Ident '=' Constant_expression { EnumInit $1 $3 }


Declarator :: { Declarator }
Declarator : Pointer Direct_declarator { BeginPointer $1 $2 } 
  | Direct_declarator { NoPointer $1 }


Direct_declarator :: { Direct_declarator }
Direct_declarator : Ident { Name $1 } 
  | '(' Declarator ')' { ParenDecl $2 }
  | Direct_declarator '[' Constant_expression ']' { InnitArray $1 $3 }
  | Direct_declarator '[' ']' { Incomplete $1 }
  | Direct_declarator '(' Parameter_type ')' { NewFuncDec $1 $3 }
  | Direct_declarator '(' ListIdent ')' { OldFuncDef $1 $3 }
  | Direct_declarator '(' ')' { OldFuncDec $1 }


Pointer :: { Pointer }
Pointer : '*' { Point } 
  | '*' ListType_qualifier { PointQual $2 }
  | '*' Pointer { PointPoint $2 }
  | '*' ListType_qualifier Pointer { PointQualPoint $2 $3 }


ListType_qualifier :: { [Type_qualifier] }
ListType_qualifier : Type_qualifier { (:[]) $1 } 
  | Type_qualifier ListType_qualifier { (:) $1 $2 }


Parameter_type :: { Parameter_type }
Parameter_type : Parameter_declarations { AllSpec $1 } 
  | Parameter_declarations ',' '...' { More $1 }


Parameter_declarations :: { Parameter_declarations }
Parameter_declarations : Parameter_declaration { ParamDec $1 } 
  | Parameter_declarations ',' Parameter_declaration { MoreParamDec $1 $3 }


Parameter_declaration :: { Parameter_declaration }
Parameter_declaration : ListDeclaration_specifier { OnlyType $1 } 
  | ListDeclaration_specifier Declarator { TypeAndParam $1 $2 }
  | ListDeclaration_specifier Abstract_declarator { Abstract $1 $2 }


ListIdent :: { [Ident] }
ListIdent : Ident { (:[]) $1 } 
  | Ident ',' ListIdent { (:) $1 $3 }


Initializer :: { Initializer }
Initializer : Exp2 { InitExpr $1 } 
  | '{' Initializers '}' { InitListOne $2 }
  | '{' Initializers ',' '}' { InitListTwo $2 }


Initializers :: { Initializers }
Initializers : Initializer { AnInit $1 } 
  | Initializers ',' Initializer { MoreInit $1 $3 }


Type_name :: { Type_name }
Type_name : ListSpec_qual { PlainType $1 } 
  | ListSpec_qual Abstract_declarator { ExtendedType $1 $2 }


Abstract_declarator :: { Abstract_declarator }
Abstract_declarator : Pointer { PointerStart $1 } 
  | Dir_abs_dec { Advanced $1 }
  | Pointer Dir_abs_dec { PointAdvanced $1 $2 }


Dir_abs_dec :: { Dir_abs_dec }
Dir_abs_dec : '(' Abstract_declarator ')' { WithinParentes $2 } 
  | '[' ']' { Array }
  | '[' Constant_expression ']' { InitiatedArray $2 }
  | Dir_abs_dec '[' ']' { UnInitiated $1 }
  | Dir_abs_dec '[' Constant_expression ']' { Initiated $1 $3 }
  | '(' ')' { OldFunction }
  | '(' Parameter_type ')' { NewFunction $2 }
  | Dir_abs_dec '(' ')' { OldFuncExpr $1 }
  | Dir_abs_dec '(' Parameter_type ')' { NewFuncExpr $1 $3 }


Stm :: { Stm }
Stm : Labeled_stm { LabelS $1 } 
  | Compound_stm { CompS $1 }
  | Expression_stm { ExprS $1 }
  | Selection_stm { SelS $1 }
  | Iter_stm { IterS $1 }
  | Jump_stm { JumpS $1 }


Labeled_stm :: { Labeled_stm }
Labeled_stm : Ident ':' Stm { SlabelOne $1 $3 } 
  | 'case' Constant_expression ':' Stm { SlabelTwo $2 $4 }
  | 'default' ':' Stm { SlabelThree $3 }


Compound_stm :: { Compound_stm }
Compound_stm : '{' '}' { ScompOne } 
  | '{' ListStm '}' { ScompTwo $2 }
  | '{' ListDec '}' { ScompThree $2 }
  | '{' ListDec ListStm '}' { ScompFour $2 $3 }


Expression_stm :: { Expression_stm }
Expression_stm : ';' { SexprOne } 
  | Exp ';' { SexprTwo $1 }


Selection_stm :: { Selection_stm }
Selection_stm : 'if' '(' Exp ')' Stm { SselOne $3 $5 } 
  | 'if' '(' Exp ')' Stm 'else' Stm { SselTwo $3 $5 $7 }
  | 'switch' '(' Exp ')' Stm { SselThree $3 $5 }


Iter_stm :: { Iter_stm }
Iter_stm : 'while' '(' Exp ')' Stm { SiterOne $3 $5 } 
  | 'do' Stm 'while' '(' Exp ')' ';' { SiterTwo $2 $5 }
  | 'for' '(' Expression_stm Expression_stm ')' Stm { SiterThree $3 $4 $6 }
  | 'for' '(' Expression_stm Expression_stm Exp ')' Stm { SiterFour $3 $4 $5 $7 }


Jump_stm :: { Jump_stm }
Jump_stm : 'goto' Ident ';' { SjumpOne $2 } 
  | 'continue' ';' { SjumpTwo }
  | 'break' ';' { SjumpThree }
  | 'return' ';' { SjumpFour }
  | 'return' Exp ';' { SjumpFive $2 }


ListStm :: { [Stm] }
ListStm : Stm { (:[]) $1 } 
  | Stm ListStm { (:) $1 $2 }


Exp :: { Exp }
Exp : Exp ',' Exp2 { Ecomma $1 $3 } 
  | Exp2 { $1 }


Exp2 :: { Exp }
Exp2 : Exp15 Assignment_op Exp2 { Eassign $1 $2 $3 } 
  | Exp3 { $1 }


Exp3 :: { Exp }
Exp3 : Exp4 '?' Exp ':' Exp3 { Econdition $1 $3 $5 } 
  | Exp4 { $1 }


Exp4 :: { Exp }
Exp4 : Exp4 '||' Exp5 { Elor $1 $3 } 
  | Exp5 { $1 }


Exp5 :: { Exp }
Exp5 : Exp5 '&&' Exp6 { Eland $1 $3 } 
  | Exp6 { $1 }


Exp6 :: { Exp }
Exp6 : Exp6 '|' Exp7 { Ebitor $1 $3 } 
  | Exp7 { $1 }


Exp7 :: { Exp }
Exp7 : Exp7 '^' Exp8 { Ebitexor $1 $3 } 
  | Exp8 { $1 }


Exp8 :: { Exp }
Exp8 : Exp8 '&' Exp9 { Ebitand $1 $3 } 
  | Exp9 { $1 }


Exp9 :: { Exp }
Exp9 : Exp9 '==' Exp10 { Eeq $1 $3 } 
  | Exp9 '!=' Exp10 { Eneq $1 $3 }
  | Exp10 { $1 }


Exp10 :: { Exp }
Exp10 : Exp10 '<' Exp11 { Elthen $1 $3 } 
  | Exp10 '>' Exp11 { Egrthen $1 $3 }
  | Exp10 '<=' Exp11 { Ele $1 $3 }
  | Exp10 '>=' Exp11 { Ege $1 $3 }
  | Exp11 { $1 }


Exp11 :: { Exp }
Exp11 : Exp11 '<<' Exp12 { Eleft $1 $3 } 
  | Exp11 '>>' Exp12 { Eright $1 $3 }
  | Exp12 { $1 }


Exp12 :: { Exp }
Exp12 : Exp12 '+' Exp13 { Eplus $1 $3 } 
  | Exp12 '-' Exp13 { Eminus $1 $3 }
  | Exp13 { $1 }


Exp13 :: { Exp }
Exp13 : Exp13 '*' Exp14 { Etimes $1 $3 } 
  | Exp13 '/' Exp14 { Ediv $1 $3 }
  | Exp13 '%' Exp14 { Emod $1 $3 }
  | Exp14 { $1 }


Exp14 :: { Exp }
Exp14 : '(' Type_name ')' Exp14 { Etypeconv $2 $4 } 
  | Exp15 { $1 }


Exp15 :: { Exp }
Exp15 : '++' Exp15 { Epreinc $2 } 
  | '--' Exp15 { Epredec $2 }
  | Unary_operator Exp14 { Epreop $1 $2 }
  | 'sizeof' Exp15 { Ebytesexpr $2 }
  | 'sizeof' '(' Type_name ')' { Ebytestype $3 }
  | Exp16 { $1 }


Exp16 :: { Exp }
Exp16 : Exp16 '[' Exp ']' { Earray $1 $3 } 
  | Exp16 '(' ')' { Efunk $1 }
  | Exp16 '(' ListExp2 ')' { Efunkpar $1 $3 }
  | Exp16 '.' Ident { Eselect $1 $3 }
  | Exp16 '->' Ident { Epoint $1 $3 }
  | Exp16 '++' { Epostinc $1 }
  | Exp16 '--' { Epostdec $1 }
  | Exp17 { $1 }


Exp17 :: { Exp }
Exp17 : Ident { Evar $1 } 
  | Constant { Econst $1 }
  | String { Estring $1 }
  | '(' Exp ')' { $2 }


Constant :: { Constant }
Constant : Double { Efloat $1 } 
  | Char { Echar $1 }
  | Unsigned { Eunsigned $1 }
  | Long { Elong $1 }
  | UnsignedLong { Eunsignlong $1 }
  | Hexadecimal { Ehexadec $1 }
  | HexUnsigned { Ehexaunsign $1 }
  | HexLong { Ehexalong $1 }
  | HexUnsLong { Ehexaunslong $1 }
  | Octal { Eoctal $1 }
  | OctalUnsigned { Eoctalunsign $1 }
  | OctalLong { Eoctallong $1 }
  | OctalUnsLong { Eoctalunslong $1 }
  | CDouble { Ecdouble $1 }
  | CFloat { Ecfloat $1 }
  | CLongDouble { Eclongdouble $1 }
  | Integer { Eint $1 }


Constant_expression :: { Constant_expression }
Constant_expression : Exp3 { Especial $1 } 


Unary_operator :: { Unary_operator }
Unary_operator : '&' { Address } 
  | '*' { Indirection }
  | '+' { Plus }
  | '-' { Negative }
  | '~' { Complement }
  | '!' { Logicalneg }


ListExp2 :: { [Exp] }
ListExp2 : Exp2 { (:[]) $1 } 
  | Exp2 ',' ListExp2 { (:) $1 $3 }


Assignment_op :: { Assignment_op }
Assignment_op : '=' { Assign } 
  | '*=' { AssignMul }
  | '/=' { AssignDiv }
  | '%=' { AssignMod }
  | '+=' { AssignAdd }
  | '-=' { AssignSub }
  | '<<=' { AssignLeft }
  | '>>=' { AssignRight }
  | '&=' { AssignAnd }
  | '^=' { AssignXor }
  | '|=' { AssignOr }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

